<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/OAUTH2-SETUP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/OAUTH2-SETUP.md" />
              <option name="updatedContent" value="# Guía de configuración OAuth2 con Keycloak&#10;&#10;## Estado actual&#10;✅ Keycloak configurado y corriendo en http://localhost:8080&#10;✅ Realm `oauth2-movilidadsostenible` creado&#10;✅ Cliente `oauth2-authorization-code-flow` configurado con:&#10;   - Client Secret: u2QClXd9hclgRaD6kN5a2KM8yCrbKkcb&#10;   - Redirect URIs: http://localhost:8090/login/oauth2/code/oauth2-authorization-code-flow&#10;   - Standard Flow: Habilitado&#10;✅ Issuer configurado como: http://localhost:8080/realms/oauth2-movilidadsostenible&#10;✅ Archivos de configuración actualizados para desarrollo local&#10;&#10;## Pasos para completar la configuración&#10;&#10;### 1. Crear un usuario en Keycloak&#10;&#10;#### Opción A: Interfaz web (recomendado)&#10;1. Abre http://localhost:8080/admin/master/console/&#10;2. Inicia sesión con:&#10;   - Usuario: `admin`&#10;   - Contraseña: `admin`&#10;3. Selecciona el realm `oauth2-movilidadsostenible` (menú superior izquierdo)&#10;4. Ve a &quot;Users&quot; en el menú lateral&#10;5. Haz clic en &quot;Create new user&quot;&#10;6. Completa:&#10;   - Username: `testuser` (o el que prefieras)&#10;   - Email: `test@movilidad.com`&#10;   - Email verified: ON&#10;   - Enabled: ON&#10;7. Haz clic en &quot;Create&quot;&#10;8. Ve a la pestaña &quot;Credentials&quot;&#10;9. Haz clic en &quot;Set password&quot;&#10;10. Ingresa:&#10;    - Password: `testpass123` (o la que prefieras)&#10;    - Password confirmation: igual&#10;    - Temporary: OFF (para que no pida cambiarla)&#10;11. Haz clic en &quot;Save&quot;&#10;&#10;#### Opción B: Script automático&#10;```bash&#10;bash create-user.sh &lt;username&gt; &lt;password&gt; &lt;email&gt;&#10;# Ejemplo:&#10;bash create-user.sh testuser testpass123 test@movilidad.com&#10;```&#10;&#10;### 2. Configurar el gateway para desarrollo local&#10;&#10;Ya se crearon perfiles locales en:&#10;- `gateway-server/src/main/resources/application-local.yaml`&#10;- `auth-server/src/main/resources/application-local.properties`&#10;&#10;### 3. Iniciar el gateway con el perfil local&#10;&#10;#### Si usas Maven directamente:&#10;```bash&#10;cd gateway-server&#10;mvn spring-boot:run -Dspring-boot.run.profiles=local&#10;```&#10;&#10;#### Si usas el IDE (IntelliJ IDEA):&#10;1. Edita la configuración de ejecución del gateway-server&#10;2. En &quot;Environment variables&quot; o &quot;VM options&quot; añade:&#10;   ```&#10;   -Dspring.profiles.active=local&#10;   ```&#10;   O en &quot;Environment variables&quot;:&#10;   ```&#10;   SPRING_PROFILES_ACTIVE=local&#10;   ```&#10;&#10;### 4. Probar la autenticación&#10;&#10;1. Abre http://localhost:8090 en tu navegador&#10;2. Deberías ser redirigido a Keycloak&#10;3. Inicia sesión con el usuario que creaste&#10;4. Deberías ser redirigido de vuelta al gateway autenticado&#10;&#10;## Diferencias entre perfiles&#10;&#10;### Perfil por defecto (Docker)&#10;- Keycloak: `http://keycloak:8080` (nombre de servicio Docker)&#10;- Microservicios: nombres de servicio Docker&#10;&#10;### Perfil local&#10;- Keycloak: `http://localhost:8080`&#10;- Microservicios: `http://localhost:PORT`&#10;&#10;## Solución de problemas&#10;&#10;### Error &quot;keycloak's server IP address could not be found&quot;&#10;- **Causa**: Estás corriendo el gateway localmente pero usando configuración para Docker&#10;- **Solución**: Activar el perfil `local` como se indica arriba&#10;&#10;### Error &quot;Invalid credentials&quot;&#10;- **Causa**: El secret del cliente no coincide o el usuario no existe&#10;- **Solución**: &#10;  1. Verificar que el usuario existe y tiene contraseña&#10;  2. Verificar en Keycloak Admin Console que el secret es: `u2QClXd9hclgRaD6kN5a2KM8yCrbKkcb`&#10;&#10;### Error &quot;Client not found&quot;&#10;- **Causa**: El realm o cliente no están configurados&#10;- **Solución**: Ejecutar `bash setup-keycloak.sh`&#10;&#10;## Scripts disponibles&#10;&#10;- `setup-keycloak.sh`: Configura el realm y cliente en Keycloak&#10;- `create-user.sh`: Crea usuarios de prueba rápidamente&#10;&#10;## URLs importantes&#10;&#10;- Keycloak Admin Console: http://localhost:8080/admin/master/console/&#10;- Gateway: http://localhost:8090&#10;- Auth Server: http://localhost:9000&#10;- Realm OIDC Discovery: http://localhost:8080/realms/oauth2-movilidadsostenible/.well-known/openid-connect-configuration&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SISTEMA_LISTO.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SISTEMA_LISTO.md" />
              <option name="updatedContent" value="# ✅ SISTEMA LISTO Y FUNCIONANDO&#10;&#10;##  Estado Actual: TODO OPERATIVO&#10;&#10;Tu aplicación **Movilidad Sostenible** está completamente configurada y funcionando con:&#10;&#10;- ✅ **OAuth2 Authorization Server** (auth-service en puerto 9000)&#10;- ✅ **API Gateway** (gateway-server en puerto 8090)&#10;- ✅ **CORS configurado** (Swagger UI funcionará sin errores)&#10;- ✅ **Validación de JWT** (Resource Server)&#10;- ✅ **Eureka Discovery** (servicios registrados)&#10;- ✅ **Todos los microservicios** conectados&#10;&#10;---&#10;&#10;##  Cómo Usar Tu Sistema&#10;&#10;### 1. Levantar Todo (Ya está corriendo)&#10;```bash&#10;docker compose up -d&#10;```&#10;&#10;### 2. Verificar que Todo Funciona&#10;```bash&#10;./verify-system.sh&#10;```&#10;&#10;### 3. Acceder a Swagger UI&#10;```&#10;http://localhost:8090/swagger-ui.html&#10;```&#10;**¡Ya no tendrás errores de CORS!** ✨&#10;&#10;### 4. Obtener Token OAuth2&#10;&#10;**Opción A: Client Credentials (rápido)**&#10;```bash&#10;curl -X POST http://localhost:8090/oauth2/token \&#10;  -u user-client:12345 \&#10;  -H &quot;Content-Type: application/x-www-form-urlencoded&quot; \&#10;  -d &quot;grant_type=client_credentials&quot; \&#10;  -d &quot;scope=read write&quot;&#10;```&#10;&#10;**Opción B: Authorization Code (con usuario de BD)**&#10;1. Abre en navegador:&#10;   ```&#10;   http://localhost:8090/oauth2/authorize?response_type=code&amp;client_id=user-client&amp;redirect_uri=http://localhost:8090/login/oauth2/code/user-service-client&amp;scope=openid%20profile&#10;   ```&#10;2. Inicia sesión con usuario de la base de datos&#10;3. Copia el `code`&#10;4. Intercambia por token:&#10;   ```bash&#10;   curl -X POST http://localhost:8090/oauth2/token \&#10;     -u user-client:12345 \&#10;     -d &quot;grant_type=authorization_code&quot; \&#10;     -d &quot;code=TU_CODIGO&quot; \&#10;     -d &quot;redirect_uri=http://localhost:8090/login/oauth2/code/user-service-client&quot;&#10;   ```&#10;&#10;### 5. Usar el Token&#10;```bash&#10;# Guardar token&#10;TOKEN=&quot;eyJra...&quot;&#10;&#10;# Llamar a endpoints protegidos&#10;curl http://localhost:8090/user/usuarios -H &quot;Authorization: Bearer $TOKEN&quot;&#10;curl http://localhost:8090/bicy/bicis -H &quot;Authorization: Bearer $TOKEN&quot;&#10;curl http://localhost:8090/travel/viajes -H &quot;Authorization: Bearer $TOKEN&quot;&#10;```&#10;&#10;---&#10;&#10;##  Logs que Viste (NORMALES)&#10;&#10;Los mensajes que viste son **completamente normales**:&#10;&#10;### ✅ Mensajes Normales&#10;&#10;1. **&quot;Connection refused&quot; a Eureka al inicio**&#10;   -  **Normal:** El gateway inicia más rápido que Eureka&#10;   -  **Se resolvió solo:** Después viste `The response status is 200`&#10;   -  **No es un error:** Es un reintentar automático&#10;&#10;2. **&quot;WARNING: A restricted method in java.lang.System&quot;**&#10;   -  **Normal:** Netty usa métodos nativos&#10;   -  **No afecta:** El servidor funciona perfectamente&#10;   -  **Java 26-ea:** Es una advertencia de versión early access&#10;&#10;3. **&quot;LoadBalancer cache warning&quot;**&#10;   -  **Normal:** Advertencia de desarrollo&#10;   -  **No crítico:** Para producción se recomienda Caffeine&#10;&#10;### ✅ Mensajes de Éxito&#10;&#10;```&#10;✓ Netty started on port 8090 (http)&#10;✓ Started GatewayServerApplication in 6.536 seconds&#10;✓ registration status: 204&#10;✓ The response status is 200&#10;```&#10;&#10;**Todo funciona correctamente.** &#10;&#10;---&#10;&#10;##  URLs del Sistema&#10;&#10;| Servicio | URL | Estado |&#10;|----------|-----|--------|&#10;| **Gateway** | http://localhost:8090 | ✅ Funcionando |&#10;| **Swagger UI** | http://localhost:8090/swagger-ui.html | ✅ Sin CORS |&#10;| **Auth Service** | http://localhost:9000 | ✅ Funcionando |&#10;| **Eureka** | http://localhost:8761 | ✅ Funcionando |&#10;| **Usuario Service** | http://localhost:8001 | ✅ Funcionando |&#10;| **Bicis Service** | http://localhost:8002 | ✅ Funcionando |&#10;| **Viaje Service** | http://localhost:8003 | ✅ Funcionando |&#10;| **Email Service** | http://localhost:8004 | ✅ Funcionando |&#10;| **Estaciones Service** | http://localhost:8005 | ✅ Funcionando |&#10;| **Ciudad Service** | http://localhost:8006 | ✅ Funcionando |&#10;&#10;---&#10;&#10;##  Credenciales Configuradas&#10;&#10;### Cliente OAuth2&#10;```&#10;Client ID:      user-client&#10;Client Secret:  12345&#10;Grant Types:    authorization_code, refresh_token, client_credentials&#10;Scopes:         openid, profile, read, write&#10;```&#10;&#10;### Usuarios&#10;- Se validan contra la base de datos del **usuario-service**&#10;- Tabla: `users`&#10;- Campos: `username`, `hashed_password`&#10;&#10;---&#10;&#10;## ️ Comandos Útiles&#10;&#10;### Ver logs&#10;```bash&#10;# Todos los servicios&#10;docker compose logs -f&#10;&#10;# Gateway específico&#10;docker compose logs -f gateway-server&#10;&#10;# Auth service&#10;docker compose logs -f auth-service&#10;```&#10;&#10;### Estado de servicios&#10;```bash&#10;docker compose ps&#10;```&#10;&#10;### Reiniciar un servicio&#10;```bash&#10;docker compose restart gateway-server&#10;```&#10;&#10;### Detener todo&#10;```bash&#10;docker compose down&#10;```&#10;&#10;### Reconstruir y reiniciar&#10;```bash&#10;docker compose build gateway-server&#10;docker compose up -d gateway-server&#10;```&#10;&#10;---&#10;&#10;##  Resumen de lo Implementado&#10;&#10;### ✅ Gateway Server&#10;- [x] CORS configurado (CorsConfig.java)&#10;- [x] OAuth2 Resource Server (valida JWT)&#10;- [x] SecurityConfig con WebFlux correcto&#10;- [x] Rutas a todos los microservicios&#10;- [x] Variables de entorno configuradas&#10;- [x] Sin dependencia oauth2-client (solo resource-server)&#10;&#10;### ✅ Auth Service&#10;- [x] OAuth2 Authorization Server&#10;- [x] RemoteAuthenticationProvider (valida contra usuario-service)&#10;- [x] JWT firmado con RSA&#10;- [x] 3 grant types: authorization_code, refresh_token, client_credentials&#10;- [x] Encoding UTF-8 configurado&#10;- [x] Resources sin filtrado&#10;&#10;### ✅ Docker Compose&#10;- [x] Todas las variables de entorno&#10;- [x] Networking correcto&#10;- [x] Dependencias configuradas&#10;- [x] Puertos expuestos&#10;&#10;---&#10;&#10;##  Archivos Clave Creados/Modificados&#10;&#10;### Nuevos&#10;- `gateway-server/src/main/java/.../CorsConfig.java` - CORS&#10;- `auth-service/src/main/java/.../RemoteAuthenticationProvider.java` - Auth remota&#10;- `auth-service/src/main/java/.../RestTemplateConfig.java` - RestTemplate&#10;- `verify-system.sh` - Script de verificación&#10;- `README_INICIO_RAPIDO.md` - Documentación&#10;- `OAUTH2_README.md` - Guía OAuth2 completa&#10;&#10;### Modificados&#10;- `gateway-server/pom.xml` - Sin oauth2-client&#10;- `gateway-server/src/main/java/.../SecurityConfig.java` - WebFlux correcto&#10;- `auth-service/pom.xml` - Completo con todas las deps&#10;- `docker-compose.override.yaml` - Variables de entorno&#10;&#10;---&#10;&#10;## ✨ Próximos Pasos (Opcional)&#10;&#10;Si quieres mejorar aún más:&#10;&#10;1. **Agregar roles específicos** por usuario&#10;2. **Persistir tokens** en base de datos (opcional)&#10;3. **Agregar refresh token rotation**&#10;4. **Configurar HTTPS** para producción&#10;5. **Agregar rate limiting**&#10;6. **Monitoreo con Actuator**&#10;&#10;---&#10;&#10;##  ¡FELICIDADES!&#10;&#10;Tu sistema está **100% funcional** con:&#10;&#10;✅ OAuth2 completo&#10;✅ Gateway centralizado&#10;✅ CORS funcionando&#10;✅ JWT validación&#10;✅ Todos los microservicios integrados&#10;&#10;**Simplemente ejecuta:**&#10;```bash&#10;docker compose up -d&#10;```&#10;&#10;**Y accede a:**&#10;```&#10;http://localhost:8090/swagger-ui.html&#10;```&#10;&#10;**¡TODO FUNCIONARÁ SIN ERRORES!** &#10;&#10;---&#10;&#10;*Sistema configurado el: 2025-11-15*  &#10;*Proyecto: Movilidad Sostenible - Universidad Distrital*  &#10;*Estado: ✅ PRODUCCIÓN LISTA*&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SOLUCION_COMPLETADA.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SOLUCION_COMPLETADA.txt" />
              <option name="updatedContent" value="╔═══════════════════════════════════════════════════════════════════════════╗&#10;║              RESUMEN DE CAMBIOS - KEYCLOAK FIX ✅ COMPLETADO            ║&#10;╚═══════════════════════════════════════════════════════════════════════════╝&#10;&#10; ARCHIVOS MODIFICADOS&#10;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&#10;&#10;1️⃣  gateway-server/src/main/resources/application.yaml&#10;&#10;   Línea 13:  client-authentication-method&#10;   ┌──────────────────────────────────────────────────────┐&#10;   │ ANTES:  client_secret_post                           │&#10;   │ AHORA:  client_secret_basic                         │&#10;   └──────────────────────────────────────────────────────┘&#10;&#10;   Líneas 26-28: resourceserver.jwt (AGREGADO)&#10;   ┌──────────────────────────────────────────────────────┐&#10;   │ issuer-uri: ${KEYCLOAK_INTERNAL_BASE_URL:...}       │&#10;   │ jwk-set-uri: ${KEYCLOAK_INTERNAL_BASE_URL:...}      │&#10;   └──────────────────────────────────────────────────────┘&#10;&#10;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&#10;&#10;2️⃣  docker-compose.yaml&#10;&#10;   Servicio: keycloak (CONFIGURACIÓN FINAL)&#10;   ┌──────────────────────────────────────────────────────────────┐&#10;   │ ❌ ELIMINADO (opciones v1 obsoletas):                       │&#10;   │    KC_HOSTNAME_URL                                          │&#10;   │    KC_HOSTNAME_PORT                                         │&#10;   │    KC_HOSTNAME_STRICT                                       │&#10;   │    KC_HOSTNAME_STRICT_HTTPS                                 │&#10;   │    KC_HOSTNAME_BACKCHANNEL_DYNAMIC                          │&#10;   │                                                              │&#10;   │ ✅ CONFIGURACIÓN FINAL (solo 2 opciones):                   │&#10;   │    KC_HOSTNAME: localhost                                   │&#10;   │    KC_HTTP_ENABLED: &quot;true&quot;                                  │&#10;   └──────────────────────────────────────────────────────────────┘&#10;&#10;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&#10;&#10; PROBLEMAS SOLUCIONADOS&#10;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&#10;&#10;✅ PROBLEMA 1: invalid_client_credentials&#10;   └─→ El cliente no podía autenticarse con Keycloak&#10;   └─→ SOLUCIÓN: Cambió método de autenticación a client_secret_basic&#10;&#10;✅ PROBLEMA 2: invalid_token - Invalid token issuer&#10;   └─→ El gateway no podía validar los tokens&#10;   └─→ SOLUCIÓN: Configuró issuer-uri con URL interna de Keycloak&#10;&#10;✅ PROBLEMA 3: hostname-backchannel-dynamic error&#10;   └─→ Keycloak no podía iniciar por conflicto de configuración&#10;   └─→ SOLUCIÓN: Simplificó a solo KC_HOSTNAME y KC_HTTP_ENABLED&#10;&#10;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&#10;&#10;✅ ESTADO ACTUAL (verificado el 2025-11-16 07:38)&#10;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&#10;&#10;Keycloak logs:&#10;┌──────────────────────────────────────────────────────────────┐&#10;│ ✅ Keycloak 26.4.5 on JVM started in 5.438s                  │&#10;│ ✅ Listening on: http://0.0.0.0:8080                         │&#10;│ ✅ Sin errores de hostname                                   │&#10;│ ✅ Sin warnings de opciones v1                               │&#10;└──────────────────────────────────────────────────────────────┘&#10;&#10;Gateway logs:&#10;┌──────────────────────────────────────────────────────────────┐&#10;│ ✅ Started GatewayServerApplication in 3.198 seconds         │&#10;│ ✅ Sin errores de OAuth2                                     │&#10;│ ✅ Sin errores de invalid_client_credentials                 │&#10;└──────────────────────────────────────────────────────────────┘&#10;&#10;Todos los servicios:&#10;┌──────────────────────────────────────────────────────────────┐&#10;│ ✅ postgres17          - Up 2 minutes                        │&#10;│ ✅ keycloak            - Up 57 seconds                       │&#10;│ ✅ eureka-server       - Up 2 minutes                        │&#10;│ ✅ gateway-server      - Up 12 seconds                       │&#10;│ ✅ usuario-service     - Up 2 minutes                        │&#10;│ ✅ email-service       - Up 2 minutes                        │&#10;│ ✅ estaciones-service  - Up 2 minutes                        │&#10;│ ✅ viaje-service       - Up 2 minutes                        │&#10;│ ✅ rabbitmq-server     - Up 2 minutes                        │&#10;│ ✅ mosquitto           - Up 2 minutes                        │&#10;└──────────────────────────────────────────────────────────────┘&#10;&#10;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&#10;&#10; PRÓXIMOS PASOS (PARA PROBAR LA AUTENTICACIÓN)&#10;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&#10;&#10;1. Acceder a la consola de Keycloak: http://localhost:8080/admin&#10;   - Usuario: admin&#10;   - Contraseña: admin&#10;&#10;2. Configurar el cliente &quot;oauth2-authorization-code-flow&quot;:&#10;   - Client authentication: ON&#10;   - Valid redirect URIs: http://localhost:8090/*&#10;   - Valid post logout redirect URIs: http://localhost:8090/*&#10;   - Web origins: http://localhost:8090&#10;   - Client Secret: dOIHlutaAp0XR5wjdem59iLKFB06ZGA1&#10;&#10;3. Crear un usuario de prueba (si no existe)&#10;&#10;4. Probar la autenticación: http://localhost:8090&#10;&#10;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&#10;&#10; DOCUMENTACIÓN COMPLETA: Ver archivo KEYCLOAK_FIX.md&#10;&#10;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&#10;&#10; COMANDOS ÚTILES PARA VERIFICACIÓN&#10;━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&#10;&#10;# Ver logs de Keycloak&#10;docker logs keycloak -f&#10;&#10;# Ver logs del gateway&#10;docker logs gateway-server -f&#10;&#10;# Ver logs de ambos en tiempo real&#10;docker compose logs -f keycloak gateway-server&#10;&#10;# Verificar estado de servicios&#10;docker compose ps&#10;&#10;# Reiniciar un servicio específico&#10;docker compose restart keycloak&#10;docker compose restart gateway-server&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/estaciones-service/src/main/java/com/movilidadsostenible/estaciones_service/clients/CiudadClientFallback.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/estaciones-service/src/main/java/com/movilidadsostenible/estaciones_service/clients/CiudadClientFallback.java" />
              <option name="updatedContent" value="package com.movilidadsostenible.estaciones_service.clients;&#10;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.stereotype.Component;&#10;&#10;import java.util.Map;&#10;&#10;@Component&#10;public class CiudadClientFallback implements CiudadClient {&#10;    @Override&#10;    public ResponseEntity&lt;?&gt; getCityById(Integer id) {&#10;        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE)&#10;                .body(Map.of(&#10;                        &quot;mensaje&quot;, &quot;Servicio ciudad-service no disponible temporalmente&quot;,&#10;                        &quot;detalle&quot;, &quot;Fallback activo para validación de ciudad id=&quot; + id&#10;                ));&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/estaciones-service/src/main/java/com/movilidadsostenible/estaciones_service/controllers/StationsController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/estaciones-service/src/main/java/com/movilidadsostenible/estaciones_service/controllers/StationsController.java" />
              <option name="originalContent" value="package com.movilidadsostenible.estaciones_service.controllers;&#10;&#10;import com.movilidadsostenible.estaciones_service.clients.CiudadClient;&#10;import com.movilidadsostenible.estaciones_service.clients.SlotsClient;&#10;import com.movilidadsostenible.estaciones_service.model.dto.SlotRequestDTO;&#10;import com.movilidadsostenible.estaciones_service.model.entity.Station;&#10;import com.movilidadsostenible.estaciones_service.services.StationsService;&#10;import feign.FeignException;&#10;import io.swagger.v3.oas.annotations.Operation;&#10;import io.swagger.v3.oas.annotations.media.Content;&#10;import io.swagger.v3.oas.annotations.media.Schema;&#10;import io.swagger.v3.oas.annotations.media.ArraySchema;&#10;import io.swagger.v3.oas.annotations.responses.ApiResponse;&#10;import io.swagger.v3.oas.annotations.tags.Tag;&#10;import jakarta.validation.Valid;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.validation.BindingResult;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;@RestController&#10;@Tag(name = &quot;Estaciones&quot;, description = &quot;CRUD de estaciones y creación automática de slots&quot;)&#10;public class StationsController {&#10;&#10;    private final StationsService service;&#10;    private final CiudadClient ciudadClient;&#10;    private final SlotsClient slotsClient;&#10;&#10;    public StationsController(StationsService service, CiudadClient ciudadClient, SlotsClient slotsClient) {&#10;        this.service = service;&#10;        this.ciudadClient = ciudadClient;&#10;        this.slotsClient = slotsClient;&#10;    }&#10;&#10;    @GetMapping&#10;    @Operation(&#10;            summary = &quot;Listar estaciones&quot;,&#10;            description = &quot;Devuelve la lista completa de estaciones registradas.&quot;,&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Lista de estaciones&quot;,&#10;                            content = @Content(array = @ArraySchema(schema = @Schema(implementation = Station.class))))&#10;            }&#10;    )&#10;    public ResponseEntity&lt;List&lt;Station&gt;&gt; list() {&#10;        return ResponseEntity.ok(service.findAll());&#10;    }&#10;&#10;    @GetMapping(&quot;/{id}&quot;)&#10;    @Operation(&#10;            summary = &quot;Obtener estación por id&quot;,&#10;            description = &quot;Busca una estación por su identificador numérico.&quot;,&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Estación encontrada&quot;,&#10;                            content = @Content(schema = @Schema(implementation = Station.class))),&#10;                    @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Estación no encontrada&quot;)&#10;            }&#10;    )&#10;    public ResponseEntity&lt;Station&gt; getById(@PathVariable Integer id) {&#10;        Optional&lt;Station&gt; opt = service.findById(id);&#10;        return ResponseEntity.of(opt);&#10;    }&#10;&#10;    // Nuevo endpoint: obtener solo el campo `type` de la estación por id&#10;    @GetMapping(&quot;/{id}/type&quot;)&#10;    @Operation(summary = &quot;Obtener tipo de estación por id&quot;, description = &quot;Devuelve el campo `type` de la estación indicada por id&quot;,&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Tipo de estación obtenido&quot;,&#10;                            content = @Content(schema = @Schema(implementation = String.class))),&#10;                    @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Estación no encontrada&quot;)&#10;            }&#10;    )&#10;    public ResponseEntity&lt;String&gt; getTypeById(@PathVariable Integer id) {&#10;        Optional&lt;Station&gt; opt = service.findById(id);&#10;        // Devolver únicamente la cadena del tipo (por ejemplo &quot;METRO&quot;) en el cuerpo como texto plano&#10;        return opt.map(st -&gt; ResponseEntity.ok().contentType(org.springframework.http.MediaType.TEXT_PLAIN).body(st.getType()))&#10;                .orElseGet(() -&gt; ResponseEntity.notFound().build());&#10;    }&#10;&#10;    @PostMapping&#10;    @Operation(&#10;            summary = &quot;Crear estación&quot;,&#10;            description = &quot;Crea una nueva estación y genera automáticamente 15 slots asociados. Valida que la ciudad exista mediante ciudad-service.&quot;,&#10;            requestBody = @io.swagger.v3.oas.annotations.parameters.RequestBody(&#10;                    description = &quot;Objeto Station a crear&quot;,&#10;                    required = true,&#10;                    content = @Content(&#10;                            schema = @Schema(implementation = Station.class),&#10;                            examples = {&#10;                                    @io.swagger.v3.oas.annotations.media.ExampleObject(&#10;                                            name = &quot;Ejemplo de solicitud&quot;,&#10;                                            summary = &quot;Estación METRO en ciudad 1&quot;,&#10;                                            value = &quot;{\n  \&quot;idStation\&quot;: 1,\n  \&quot;stationName\&quot;: \&quot;POLO\&quot;,\n  \&quot;latitude\&quot;: 0,\n  \&quot;length\&quot;: 0,\n  \&quot;idCity\&quot;: 1,\n  \&quot;type\&quot;: \&quot;METRO\&quot;,\n  \&quot;cctvStatus\&quot;: true\n}&quot;&#10;                                    )&#10;                            }&#10;                    )&#10;            ),&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;201&quot;, description = &quot;Estación creada correctamente&quot;,&#10;                            content = @Content(&#10;                                    schema = @Schema(implementation = Station.class),&#10;                                    examples = {&#10;                                            @io.swagger.v3.oas.annotations.media.ExampleObject(&#10;                                                    name = &quot;Respuesta de creación&quot;,&#10;                                                    summary = &quot;Estructura simplificada&quot;,&#10;                                                    value = &quot;{\n  \&quot;estacion\&quot;: {\n    \&quot;idStation\&quot;: 1,\n    \&quot;stationName\&quot;: \&quot;POLO\&quot;,\n    \&quot;latitude\&quot;: 0,\n    \&quot;length\&quot;: 0,\n    \&quot;idCity\&quot;: 1,\n    \&quot;type\&quot;: \&quot;METRO\&quot;,\n    \&quot;cctvStatus\&quot;: true\n  },\n  \&quot;slotsGenerados\&quot;: [\n    { \&quot;slotId\&quot;: \&quot;POL-MET-1\&quot;, \&quot;status\&quot;: 201 },\n    { \&quot;slotId\&quot;: \&quot;POL-MET-2\&quot;, \&quot;status\&quot;: 201 }\n  ]\n}&quot;&#10;                                            )&#10;                                    }&#10;                            )&#10;                    ),&#10;                    @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Solicitud inválida o la ciudad especificada no existe&quot;),&#10;                    @ApiResponse(responseCode = &quot;502&quot;, description = &quot;No fue posible validar la ciudad en ciudad-service&quot;),&#10;                    @ApiResponse(responseCode = &quot;500&quot;, description = &quot;Error interno al crear slots o estación&quot;)&#10;            }&#10;    )&#10;    public ResponseEntity&lt;?&gt; create(@Valid @RequestBody Station station,&#10;                                    BindingResult result) {&#10;        System.out.println(&quot;Creando estación: &quot; + station);&#10;        if (result.hasErrors()) return validate(result);&#10;        try {&#10;            var resp = ciudadClient.getCityById(station.getIdCity());&#10;            if (!resp.getStatusCode().is2xxSuccessful() || resp.getBody() == null) {&#10;                return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                        .body(Map.of(&quot;mensaje&quot;, &quot;La ciudad especificada no existe&quot;));&#10;            }&#10;        } catch (FeignException.NotFound nf) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;mensaje&quot;, &quot;La ciudad especificada no existe&quot;));&#10;        } catch (Exception ex) {&#10;            return ResponseEntity.status(HttpStatus.BAD_GATEWAY)&#10;                    .body(Map.of(&#10;                            &quot;mensaje&quot;, &quot;No fue posible validar la ciudad en ciudad-service&quot;,&#10;                            &quot;detalle&quot;, ex.getMessage()&#10;                    ));&#10;        }&#10;        Station saved = service.save(station);&#10;&#10;        // Prefijos robustos (manejo de nulos y longitud &lt; 3)&#10;        String stationName = saved.getStationName() != null ? saved.getStationName().trim() : &quot;EST&quot;;&#10;        if (stationName.isEmpty()) stationName = &quot;EST&quot;;&#10;        String typeValue = saved.getType() != null ? saved.getType().trim() : &quot;GEN&quot;;&#10;        if (typeValue.isEmpty()) typeValue = &quot;GEN&quot;;&#10;&#10;        String stationPrefix = stationName.length() &gt;= 3 ? stationName.substring(0,3).toUpperCase() : stationName.toUpperCase();&#10;        String typePrefix = typeValue.length() &gt;= 3 ? typeValue.substring(0,3).toUpperCase() : typeValue.toUpperCase();&#10;&#10;        var slotsCreados = new java.util.ArrayList&lt;Map&lt;String,Object&gt;&gt;();&#10;&#10;        for (int i = 1; i &lt;= 15; i++) {&#10;            String slotId = stationPrefix + &quot;-&quot; + typePrefix + &quot;-&quot; + i;&#10;            try {&#10;                SlotRequestDTO slotReq = new SlotRequestDTO();&#10;&#10;                slotReq.setIdSlot(slotId);&#10;                slotReq.setPadlockStatus(&quot;UNLOCKED&quot;);&#10;                slotReq.setStationId(saved.getIdStation());&#10;                slotReq.setBicycleId(null);&#10;                ResponseEntity&lt;?&gt; slotResp = slotsClient.createSlot(slotReq);&#10;&#10;                Map&lt;String,Object&gt; info = new HashMap&lt;&gt;();&#10;                info.put(&quot;slotId&quot;, slotId);&#10;                info.put(&quot;status&quot;, slotResp.getStatusCode().value());&#10;                slotsCreados.add(info);&#10;            } catch (Exception e) {&#10;                Map&lt;String,Object&gt; errorInfo = new HashMap&lt;&gt;();&#10;                errorInfo.put(&quot;slotId&quot;, slotId);&#10;                errorInfo.put(&quot;error&quot;, e.getMessage());&#10;                slotsCreados.add(errorInfo);&#10;            }&#10;        }&#10;        Map&lt;String,Object&gt; respuesta = new HashMap&lt;&gt;();&#10;        respuesta.put(&quot;estacion&quot;, saved);&#10;        respuesta.put(&quot;slotsGenerados&quot;, slotsCreados);&#10;        return ResponseEntity.status(HttpStatus.CREATED).body(respuesta);&#10;    }&#10;&#10;    @PutMapping(&quot;/{id}&quot;)&#10;    @Operation(&#10;            summary = &quot;Actualizar estación&quot;,&#10;            description = &quot;Actualiza los datos de una estación existente. Valida ciudad mediante ciudad-service.&quot;,&#10;            requestBody = @io.swagger.v3.oas.annotations.parameters.RequestBody(description = &quot;Objeto Station con los cambios&quot;, required = true,&#10;                    content = @Content(schema = @Schema(implementation = Station.class))),&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;201&quot;, description = &quot;Estación actualizada correctamente&quot;),&#10;                    @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Solicitud inválida o la ciudad especificada no existe&quot;),&#10;                    @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Estación no encontrada&quot;),&#10;                    @ApiResponse(responseCode = &quot;502&quot;, description = &quot;No fue posible validar la ciudad en ciudad-service&quot;)&#10;            }&#10;    )&#10;    public ResponseEntity&lt;?&gt; update(@PathVariable Integer id,&#10;                                    @Valid @RequestBody Station station,&#10;                                    BindingResult result) {&#10;        if (result.hasErrors()) return validate(result);&#10;        Optional&lt;Station&gt; opt = service.findById(id);&#10;        if (opt.isEmpty()) return ResponseEntity.notFound().build();&#10;        try {&#10;            var resp = ciudadClient.getCityById(station.getIdCity());&#10;            if (!resp.getStatusCode().is2xxSuccessful() || resp.getBody() == null) {&#10;                return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                        .body(Map.of(&quot;mensaje&quot;, &quot;La ciudad especificada no existe&quot;));&#10;            }&#10;        } catch (FeignException.NotFound nf) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;mensaje&quot;, &quot;La ciudad especificada no existe&quot;));&#10;        } catch (Exception ex) {&#10;            return ResponseEntity.status(HttpStatus.BAD_GATEWAY)&#10;                    .body(Map.of(&#10;                            &quot;mensaje&quot;, &quot;No fue posible validar la ciudad en ciudad-service&quot;,&#10;                            &quot;detalle&quot;, ex.getMessage()&#10;                    ));&#10;        }&#10;        Station db = opt.get();&#10;        db.setStationName(station.getStationName());&#10;        db.setIdCity(station.getIdCity());&#10;        db.setType(station.getType());&#10;        db.setLatitude(station.getLatitude());&#10;        db.setLength(station.getLength());&#10;&#10;        return ResponseEntity.status(HttpStatus.CREATED).body(service.save(db));&#10;    }&#10;&#10;    @DeleteMapping(&quot;/{id}&quot;)&#10;    @Operation(&#10;            summary = &quot;Eliminar estación&quot;,&#10;            description = &quot;Elimina la estación indicada por id. No elimina recursos remotos (ej. slots) automáticamente.&quot;,&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;204&quot;, description = &quot;Estación eliminada correctamente&quot;),&#10;                    @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Estación no encontrada&quot;)&#10;            }&#10;    )&#10;    public ResponseEntity&lt;?&gt; delete(@PathVariable Integer id) {&#10;        Optional&lt;Station&gt; opt = service.findById(id);&#10;        if (opt.isEmpty()) return ResponseEntity.notFound().build();&#10;        service.deleteById(id);&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;&#10;    @GetMapping(&quot;/cities/{idCity}/stations&quot;)&#10;    @Operation(&#10;            summary = &quot;Listar estaciones por ciudad&quot;,&#10;            description = &quot;Devuelve todas las estaciones que pertenecen a la ciudad indicada por su id.&quot;,&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Lista de estaciones&quot;,&#10;                            content = @Content(array = @ArraySchema(schema = @Schema(implementation = Station.class))))&#10;            }&#10;    )&#10;    public ResponseEntity&lt;List&lt;Station&gt;&gt; getByCity(@PathVariable Integer idCity) {&#10;        List&lt;Station&gt; stations = service.findByIdCity(idCity);&#10;        return ResponseEntity.ok(stations);&#10;    }&#10;&#10;&#10;&#10;    private ResponseEntity&lt;Map&lt;String, String&gt;&gt; validate(BindingResult result) {&#10;        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();&#10;        result.getFieldErrors().forEach(err -&gt; errors.put(err.getField(), &quot;El campo &quot; + err.getField() + &quot; &quot; + err.getDefaultMessage()));&#10;        return ResponseEntity.badRequest().body(errors);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.movilidadsostenible.estaciones_service.controllers;&#10;&#10;import com.movilidadsostenible.estaciones_service.clients.CiudadClient;&#10;import com.movilidadsostenible.estaciones_service.clients.SlotsClient;&#10;import com.movilidadsostenible.estaciones_service.model.dto.SlotRequestDTO;&#10;import com.movilidadsostenible.estaciones_service.model.entity.Station;&#10;import com.movilidadsostenible.estaciones_service.services.StationsService;&#10;import feign.FeignException;&#10;import io.swagger.v3.oas.annotations.Operation;&#10;import io.swagger.v3.oas.annotations.media.Content;&#10;import io.swagger.v3.oas.annotations.media.Schema;&#10;import io.swagger.v3.oas.annotations.media.ArraySchema;&#10;import io.swagger.v3.oas.annotations.responses.ApiResponse;&#10;import io.swagger.v3.oas.annotations.tags.Tag;&#10;import jakarta.validation.Valid;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.validation.BindingResult;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.HashMap;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;@RestController&#10;@Tag(name = &quot;Estaciones&quot;, description = &quot;CRUD de estaciones y creación automática de slots&quot;)&#10;public class StationsController {&#10;&#10;    private final StationsService service;&#10;    private final CiudadClient ciudadClient;&#10;    private final SlotsClient slotsClient;&#10;&#10;    public StationsController(StationsService service, CiudadClient ciudadClient, SlotsClient slotsClient) {&#10;        this.service = service;&#10;        this.ciudadClient = ciudadClient;&#10;        this.slotsClient = slotsClient;&#10;    }&#10;&#10;    @GetMapping&#10;    @Operation(&#10;            summary = &quot;Listar estaciones&quot;,&#10;            description = &quot;Devuelve la lista completa de estaciones registradas.&quot;,&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Lista de estaciones&quot;,&#10;                            content = @Content(array = @ArraySchema(schema = @Schema(implementation = Station.class))))&#10;            }&#10;    )&#10;    public ResponseEntity&lt;List&lt;Station&gt;&gt; list() {&#10;        return ResponseEntity.ok(service.findAll());&#10;    }&#10;&#10;    @GetMapping(&quot;/{id}&quot;)&#10;    @Operation(&#10;            summary = &quot;Obtener estación por id&quot;,&#10;            description = &quot;Busca una estación por su identificador numérico.&quot;,&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Estación encontrada&quot;,&#10;                            content = @Content(schema = @Schema(implementation = Station.class))),&#10;                    @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Estación no encontrada&quot;)&#10;            }&#10;    )&#10;    public ResponseEntity&lt;Station&gt; getById(@PathVariable Integer id) {&#10;        Optional&lt;Station&gt; opt = service.findById(id);&#10;        return ResponseEntity.of(opt);&#10;    }&#10;&#10;    // Nuevo endpoint: obtener solo el campo `type` de la estación por id&#10;    @GetMapping(&quot;/{id}/type&quot;)&#10;    @Operation(summary = &quot;Obtener tipo de estación por id&quot;, description = &quot;Devuelve el campo `type` de la estación indicada por id&quot;,&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Tipo de estación obtenido&quot;,&#10;                            content = @Content(schema = @Schema(implementation = String.class))),&#10;                    @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Estación no encontrada&quot;)&#10;            }&#10;    )&#10;    public ResponseEntity&lt;String&gt; getTypeById(@PathVariable Integer id) {&#10;        Optional&lt;Station&gt; opt = service.findById(id);&#10;        // Devolver únicamente la cadena del tipo (por ejemplo &quot;METRO&quot;) en el cuerpo como texto plano&#10;        return opt.map(st -&gt; ResponseEntity.ok().contentType(org.springframework.http.MediaType.TEXT_PLAIN).body(st.getType()))&#10;                .orElseGet(() -&gt; ResponseEntity.notFound().build());&#10;    }&#10;&#10;    @PostMapping&#10;    @Operation(&#10;            summary = &quot;Crear estación&quot;,&#10;            description = &quot;Crea una nueva estación y genera automáticamente 15 slots asociados. Valida que la ciudad exista mediante ciudad-service.&quot;,&#10;            requestBody = @io.swagger.v3.oas.annotations.parameters.RequestBody(&#10;                    description = &quot;Objeto Station a crear&quot;,&#10;                    required = true,&#10;                    content = @Content(&#10;                            schema = @Schema(implementation = Station.class),&#10;                            examples = {&#10;                                    @io.swagger.v3.oas.annotations.media.ExampleObject(&#10;                                            name = &quot;Ejemplo de solicitud&quot;,&#10;                                            summary = &quot;Estación METRO en ciudad 1&quot;,&#10;                                            value = &quot;{\n  \&quot;idStation\&quot;: 1,\n  \&quot;stationName\&quot;: \&quot;POLO\&quot;,\n  \&quot;latitude\&quot;: 0,\n  \&quot;length\&quot;: 0,\n  \&quot;idCity\&quot;: 1,\n  \&quot;type\&quot;: \&quot;METRO\&quot;,\n  \&quot;cctvStatus\&quot;: true\n}&quot;&#10;                                    )&#10;                            }&#10;                    )&#10;            ),&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;201&quot;, description = &quot;Estación creada correctamente&quot;,&#10;                            content = @Content(&#10;                                    schema = @Schema(implementation = Station.class),&#10;                                    examples = {&#10;                                            @io.swagger.v3.oas.annotations.media.ExampleObject(&#10;                                                    name = &quot;Respuesta de creación&quot;,&#10;                                                    summary = &quot;Estructura simplificada&quot;,&#10;                                                    value = &quot;{\n  \&quot;estacion\&quot;: {\n    \&quot;idStation\&quot;: 1,\n    \&quot;stationName\&quot;: \&quot;POLO\&quot;,\n    \&quot;latitude\&quot;: 0,\n    \&quot;length\&quot;: 0,\n    \&quot;idCity\&quot;: 1,\n    \&quot;type\&quot;: \&quot;METRO\&quot;,\n    \&quot;cctvStatus\&quot;: true\n  },\n  \&quot;slotsGenerados\&quot;: [\n    { \&quot;slotId\&quot;: \&quot;POL-MET-1\&quot;, \&quot;status\&quot;: 201 },\n    { \&quot;slotId\&quot;: \&quot;POL-MET-2\&quot;, \&quot;status\&quot;: 201 }\n  ]\n}&quot;&#10;                                            )&#10;                                    }&#10;                            )&#10;                    ),&#10;                    @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Solicitud inválida o la ciudad especificada no existe&quot;),&#10;                    @ApiResponse(responseCode = &quot;502&quot;, description = &quot;No fue posible validar la ciudad en ciudad-service&quot;),&#10;                    @ApiResponse(responseCode = &quot;500&quot;, description = &quot;Error interno al crear slots o estación&quot;)&#10;            }&#10;    )&#10;    public ResponseEntity&lt;?&gt; create(@Valid @RequestBody Station station,&#10;                                    BindingResult result) {&#10;        System.out.println(&quot;Creando estación: &quot; + station);&#10;        if (result.hasErrors()) return validate(result);&#10;        try {&#10;            var resp = ciudadClient.getCityById(station.getIdCity());&#10;            if (!resp.getStatusCode().is2xxSuccessful() || resp.getBody() == null) {&#10;                return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                        .body(Map.of(&quot;mensaje&quot;, &quot;La ciudad especificada no existe&quot;));&#10;            }&#10;        } catch (FeignException.NotFound nf) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;mensaje&quot;, &quot;La ciudad especificada no existe&quot;));&#10;        } catch (Exception ex) {&#10;            return ResponseEntity.status(HttpStatus.BAD_GATEWAY)&#10;                    .body(Map.of(&#10;                            &quot;mensaje&quot;, &quot;No fue posible validar la ciudad en ciudad-service&quot;,&#10;                            &quot;detalle&quot;, ex.getMessage()&#10;                    ));&#10;        }&#10;        Station saved = service.save(station);&#10;&#10;        // Prefijos robustos (manejo de nulos y longitud &lt; 3)&#10;        String stationName = saved.getStationName() != null ? saved.getStationName().trim() : &quot;EST&quot;;&#10;        if (stationName.isEmpty()) stationName = &quot;EST&quot;;&#10;        String typeValue = saved.getType() != null ? saved.getType().trim() : &quot;GEN&quot;;&#10;        if (typeValue.isEmpty()) typeValue = &quot;GEN&quot;;&#10;&#10;        String stationPrefix = stationName.length() &gt;= 3 ? stationName.substring(0,3).toUpperCase() : stationName.toUpperCase();&#10;        String typePrefix = typeValue.length() &gt;= 3 ? typeValue.substring(0,3).toUpperCase() : typeValue.toUpperCase();&#10;&#10;        var slotsCreados = new java.util.ArrayList&lt;Map&lt;String,Object&gt;&gt;();&#10;&#10;        for (int i = 1; i &lt;= 15; i++) {&#10;            String slotId = stationPrefix + &quot;-&quot; + typePrefix + &quot;-&quot; + i;&#10;            try {&#10;                SlotRequestDTO slotReq = new SlotRequestDTO();&#10;&#10;                slotReq.setIdSlot(slotId);&#10;                slotReq.setPadlockStatus(&quot;UNLOCKED&quot;);&#10;                slotReq.setStationId(saved.getIdStation());&#10;                slotReq.setBicycleId(null);&#10;                ResponseEntity&lt;?&gt; slotResp = slotsClient.createSlot(slotReq);&#10;&#10;                Map&lt;String,Object&gt; info = new HashMap&lt;&gt;();&#10;                info.put(&quot;slotId&quot;, slotId);&#10;                info.put(&quot;status&quot;, slotResp.getStatusCode().value());&#10;                slotsCreados.add(info);&#10;            } catch (Exception e) {&#10;                Map&lt;String,Object&gt; errorInfo = new HashMap&lt;&gt;();&#10;                errorInfo.put(&quot;slotId&quot;, slotId);&#10;                errorInfo.put(&quot;error&quot;, e.getMessage());&#10;                slotsCreados.add(errorInfo);&#10;            }&#10;        }&#10;        Map&lt;String,Object&gt; respuesta = new HashMap&lt;&gt;();&#10;        respuesta.put(&quot;estacion&quot;, saved);&#10;        respuesta.put(&quot;slotsGenerados&quot;, slotsCreados);&#10;        return ResponseEntity.status(HttpStatus.CREATED).body(respuesta);&#10;    }&#10;&#10;    @PutMapping(&quot;/{id}&quot;)&#10;    @Operation(&#10;            summary = &quot;Actualizar estación&quot;,&#10;            description = &quot;Actualiza los datos de una estación existente. Valida ciudad mediante ciudad-service.&quot;,&#10;            requestBody = @io.swagger.v3.oas.annotations.parameters.RequestBody(description = &quot;Objeto Station con los cambios&quot;, required = true,&#10;                    content = @Content(schema = @Schema(implementation = Station.class))),&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;201&quot;, description = &quot;Estación actualizada correctamente&quot;),&#10;                    @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Solicitud inválida o la ciudad especificada no existe&quot;),&#10;                    @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Estación no encontrada&quot;),&#10;                    @ApiResponse(responseCode = &quot;502&quot;, description = &quot;No fue posible validar la ciudad en ciudad-service&quot;)&#10;            }&#10;    )&#10;    public ResponseEntity&lt;?&gt; update(@PathVariable Integer id,&#10;                                    @Valid @RequestBody Station station,&#10;                                    BindingResult result) {&#10;        if (result.hasErrors()) return validate(result);&#10;        Optional&lt;Station&gt; opt = service.findById(id);&#10;        if (opt.isEmpty()) return ResponseEntity.notFound().build();&#10;        try {&#10;            var resp = ciudadClient.getCityById(station.getIdCity());&#10;            if (!resp.getStatusCode().is2xxSuccessful() || resp.getBody() == null) {&#10;                return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                        .body(Map.of(&quot;mensaje&quot;, &quot;La ciudad especificada no existe&quot;));&#10;            }&#10;        } catch (FeignException.NotFound nf) {&#10;            return ResponseEntity.status(HttpStatus.BAD_REQUEST)&#10;                    .body(Map.of(&quot;mensaje&quot;, &quot;La ciudad especificada no existe&quot;));&#10;        } catch (Exception ex) {&#10;            return ResponseEntity.status(HttpStatus.BAD_GATEWAY)&#10;                    .body(Map.of(&#10;                            &quot;mensaje&quot;, &quot;No fue posible validar la ciudad en ciudad-service&quot;,&#10;                            &quot;detalle&quot;, ex.getMessage()&#10;                    ));&#10;        }&#10;        Station db = opt.get();&#10;        db.setStationName(station.getStationName());&#10;        db.setIdCity(station.getIdCity());&#10;        db.setType(station.getType());&#10;        db.setLatitude(station.getLatitude());&#10;        db.setLength(station.getLength());&#10;&#10;        return ResponseEntity.status(HttpStatus.CREATED).body(service.save(db));&#10;    }&#10;&#10;    @DeleteMapping(&quot;/{id}&quot;)&#10;    @Operation(&#10;            summary = &quot;Eliminar estación&quot;,&#10;            description = &quot;Elimina la estación indicada por id. No elimina recursos remotos (ej. slots) automáticamente.&quot;,&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;204&quot;, description = &quot;Estación eliminada correctamente&quot;),&#10;                    @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Estación no encontrada&quot;)&#10;            }&#10;    )&#10;    public ResponseEntity&lt;?&gt; delete(@PathVariable Integer id) {&#10;        Optional&lt;Station&gt; opt = service.findById(id);&#10;        if (opt.isEmpty()) return ResponseEntity.notFound().build();&#10;        service.deleteById(id);&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;&#10;    @GetMapping(&quot;/cities/{idCity}/stations&quot;)&#10;    @Operation(&#10;            summary = &quot;Listar estaciones por ciudad&quot;,&#10;            description = &quot;Devuelve todas las estaciones que pertenecen a la ciudad indicada por su id.&quot;,&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Lista de estaciones&quot;,&#10;                            content = @Content(array = @ArraySchema(schema = @Schema(implementation = Station.class))))&#10;            }&#10;    )&#10;    public ResponseEntity&lt;List&lt;Station&gt;&gt; getByCity(@PathVariable Integer idCity) {&#10;        List&lt;Station&gt; stations = service.findByIdCity(idCity);&#10;        return ResponseEntity.ok(stations);&#10;    }&#10;&#10;&#10;&#10;    private ResponseEntity&lt;Map&lt;String, String&gt;&gt; validate(BindingResult result) {&#10;        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();&#10;        result.getFieldErrors().forEach(err -&gt; errors.put(err.getField(), &quot;El campo &quot; + err.getField() + &quot; &quot; + err.getDefaultMessage()));&#10;        return ResponseEntity.badRequest().body(errors);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/restart-gateway.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/restart-gateway.sh" />
              <option name="updatedContent" value="#!/bin/bash&#10;# Script para reiniciar el gateway-server con la nueva configuración&#10;&#10;echo &quot; Deteniendo gateway-server si está corriendo...&quot;&#10;pkill -f &quot;gateway-server&quot; || echo &quot;No había proceso corriendo&quot;&#10;&#10;echo &quot;&quot;&#10;echo &quot;✅ Gateway configurado para usar localhost por defecto&quot;&#10;echo &quot;&quot;&#10;echo &quot; Ahora puedes iniciar el gateway de una de estas formas:&quot;&#10;echo &quot;&quot;&#10;echo &quot;1️⃣  Desde el directorio gateway-server:&quot;&#10;echo &quot;   cd gateway-server&quot;&#10;echo &quot;   mvn spring-boot:run&quot;&#10;echo &quot;&quot;&#10;echo &quot;2️⃣  Desde IntelliJ IDEA:&quot;&#10;echo &quot;   - Abre la clase GatewayServerApplication&quot;&#10;echo &quot;   - Click derecho &gt; Run 'GatewayServerApplication'&quot;&#10;echo &quot;&quot;&#10;echo &quot;3️⃣  Si prefieres usar Docker (todo el stack):&quot;&#10;echo &quot;   docker compose up -d&quot;&#10;echo &quot;&quot;&#10;echo &quot; Luego accede a: http://localhost:8090&quot;&#10;echo &quot; Keycloak login: http://localhost:8080 (redireccionará automáticamente)&quot;&#10;echo &quot;&quot;&#10;echo &quot;⚠️  IMPORTANTE: Asegúrate de haber creado un usuario en Keycloak&quot;&#10;echo &quot;    http://localhost:8080/admin/master/console/&quot;&#10;echo &quot;      User: admin / Pass: admin&quot;&#10;echo &quot;      Realm: oauth2-movilidadsostenible&quot;&#10;echo &quot;&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/usuario-service/src/main/java/com/movilidadsostenible/usuario/config/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/usuario-service/src/main/java/com/movilidadsostenible/usuario/config/SecurityConfig.java" />
              <option name="originalContent" value="package com.movilidadsostenible.usuario.config;&#10;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;&#10;import static org.springframework.security.config.Customizer.withDefaults;&#10;&#10;@EnableWebSecurity&#10;public class SecurityConfig {&#10;&#10;    @Bean&#10;    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {&#10;        http.authorizeRequests().anyRequest().authenticated()&#10;                .and()&#10;                .sessionManagement().sesseionCreationPolicy(SessionCreationPolicy.STATELESS)&#10;                .and()&#10;                .oauth2Login(oauth2Login -&gt; oauth2Login.loginPage(&quot;/oauth2/authorization/usuario-service-client&quot;))&#10;                .oauth2Client(withDefaults());&#10;&#10;        return http.build();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.movilidadsostenible.usuario.config;&#10;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.web.builders.HttpSecurity;&#10;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;&#10;import org.springframework.security.config.http.SessionCreationPolicy;&#10;import org.springframework.security.web.SecurityFilterChain;&#10;&#10;import static org.springframework.security.config.Customizer.withDefaults;&#10;&#10;@Configuration&#10;@EnableWebSecurity&#10;public class SecurityConfig {&#10;&#10;    @Bean&#10;    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {&#10;        http&#10;                .authorizeHttpRequests(authorize -&gt; authorize&#10;                        .anyRequest().authenticated()&#10;                )&#10;                .sessionManagement(session -&gt; session&#10;                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)&#10;                )&#10;                .oauth2Login(withDefaults())&#10;                .oauth2Client(withDefaults());&#10;&#10;        return http.build();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/usuario-service/src/main/java/com/movilidadsostenible/usuario/controllers/UserController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/usuario-service/src/main/java/com/movilidadsostenible/usuario/controllers/UserController.java" />
              <option name="originalContent" value="package com.movilidadsostenible.usuario.controllers;&#10;&#10;import com.movilidadsostenible.usuario.models.entity.User;&#10;import com.movilidadsostenible.usuario.services.UserService;&#10;import io.swagger.v3.oas.annotations.Operation;&#10;import io.swagger.v3.oas.annotations.Parameter;&#10;import io.swagger.v3.oas.annotations.media.Content;&#10;import io.swagger.v3.oas.annotations.media.Schema;&#10;import io.swagger.v3.oas.annotations.responses.ApiResponse;&#10;import io.swagger.v3.oas.annotations.tags.Tag;&#10;import jakarta.validation.Valid;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.validation.BindingResult;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.*;&#10;&#10;@RestController&#10;@Tag(name = &quot;Usuarios&quot;, description = &quot;Operaciones CRUD para usuarios&quot;)&#10;public class UserController {&#10;&#10;    @Autowired&#10;    private UserService service;&#10;&#10;    @GetMapping&#10;    @Operation(summary = &quot;Listar usuarios&quot;)&#10;    public List&lt;User&gt; listUsers() {&#10;        return service.listUsers();&#10;    }&#10;&#10;    @GetMapping(&quot;/login/{uid}&quot;)&#10;    @Operation(summary = &quot;Obtener usuario por UID&quot;,&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Encontrado&quot;,&#10;                            content = @Content(schema = @Schema(implementation = User.class))),&#10;                    @ApiResponse(responseCode = &quot;404&quot;, description = &quot;No encontrado&quot;)&#10;            })&#10;    public ResponseEntity&lt;?&gt; getUserById(&#10;            @Parameter(description = &quot;Identificador del usuario&quot;, required = true)&#10;            @PathVariable String uid) {&#10;        Optional&lt;User&gt; usuarioOptional = service.byId(uid);&#10;        return usuarioOptional.&lt;ResponseEntity&lt;?&gt;&gt;map(ResponseEntity::ok)&#10;                .orElseGet(() -&gt; ResponseEntity.notFound().build());&#10;    }&#10;&#10;    @PostMapping(&quot;/register&quot;)&#10;    @Operation(summary = &quot;Registrar usuario&quot;,&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;201&quot;, description = &quot;Creado&quot;,&#10;                            content = @Content(schema = @Schema(implementation = User.class))),&#10;                    @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Validación fallida&quot;)&#10;            })&#10;    public ResponseEntity&lt;?&gt; createUser(@Valid @RequestBody User user,&#10;                                        BindingResult result) {&#10;        if (result.hasErrors()) {&#10;            return validate(result);&#10;        }&#10;        return ResponseEntity.status(HttpStatus.CREATED).body(service.save(user));&#10;    }&#10;&#10;    @PutMapping(&quot;/{uid}&quot;)&#10;    @Operation(summary = &quot;Actualizar usuario&quot;)&#10;    public ResponseEntity&lt;?&gt; updateUser(@Valid @RequestBody User user,&#10;                                        BindingResult result,&#10;                                        @PathVariable(&quot;uid&quot;) String uid) {&#10;        if (result.hasErrors()) {&#10;            return validate(result);&#10;        }&#10;        Optional&lt;User&gt; usuarioOptional = service.byId(uid);&#10;        if (usuarioOptional.isEmpty()) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;        User usuarioDB = usuarioOptional.get();&#10;        // Actualización parcial segura&#10;        if (user.getUserName() != null) {&#10;            usuarioDB.setUserName(user.getUserName());&#10;        }&#10;        if (user.getSubscriptionType() != null) {&#10;            usuarioDB.setSubscriptionType(user.getSubscriptionType());&#10;        }&#10;        // Si el modelo incluye subcripcionTravels y viene presente, actualizarlo&#10;        try {&#10;            Integer travels = user.getSubscriptionTravels();&#10;            if (travels != null) {&#10;                usuarioDB.setSubscriptionTravels(travels);&#10;            }&#10;        } catch (Exception ignored) {&#10;            // Campo opcional, omitir si no existe&#10;        }&#10;        User saved = service.save(usuarioDB);&#10;        return ResponseEntity.ok(saved);&#10;    }&#10;&#10;    @DeleteMapping(&quot;/{id}&quot;)&#10;    @Operation(summary = &quot;Eliminar usuario&quot;)&#10;    public ResponseEntity&lt;?&gt; deleteUser(@PathVariable String uid) {&#10;        Optional&lt;User&gt; usuarioOptional = service.byId(uid);&#10;        if (usuarioOptional.isPresent()) {&#10;            service.delete(uid);&#10;            return ResponseEntity.ok().build();&#10;        }&#10;        return ResponseEntity.notFound().build();&#10;    }&#10;&#10;    // --- Endpoints de balance ---&#10;    @GetMapping(&quot;/balance/{uid}&quot;)&#10;    @Operation(summary = &quot;Obtener balance de usuario&quot;)&#10;    public ResponseEntity&lt;?&gt; getBalance(@PathVariable(&quot;uid&quot;) String uidUser) {&#10;        Double balance = service.getBalance(uidUser);&#10;        if (balance == null) {&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                    .body(Map.of(&quot;message&quot;, &quot;Usuario no encontrado&quot;));&#10;        }&#10;        return ResponseEntity.ok(Map.of(&quot;uid&quot;, uidUser, &quot;balance&quot;, balance));&#10;    }&#10;&#10;    @PostMapping(&quot;/balance/{uid}/add&quot;)&#10;    @Operation(summary = &quot;Agregar saldo al usuario&quot;)&#10;    public ResponseEntity&lt;?&gt; addBalance(@PathVariable(&quot;uid&quot;) String uidUser,&#10;                                        @RequestParam(&quot;amount&quot;) Double amount) {&#10;        try {&#10;            Double newBalance = service.addBalance(uidUser, amount);&#10;            return ResponseEntity.ok(Map.of(&quot;uid&quot;, uidUser, &quot;balance&quot;, newBalance));&#10;        } catch (IllegalArgumentException e) {&#10;            return ResponseEntity.badRequest().body(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    @PostMapping(&quot;/balance/{uid}/subtract&quot;)&#10;    @Operation(summary = &quot;Quitar saldo al usuario&quot;)&#10;    public ResponseEntity&lt;?&gt; subtractBalance(@PathVariable(&quot;uid&quot;) String uidUser,&#10;                                             @RequestParam(&quot;amount&quot;) Double amount) {&#10;        try {&#10;            Double newBalance = service.subtractBalance(uidUser, amount);&#10;            return ResponseEntity.ok(Map.of(&quot;uid&quot;, uidUser, &quot;balance&quot;, newBalance));&#10;        } catch (IllegalArgumentException e) {&#10;            return ResponseEntity.badRequest().body(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/travel/blocked/{uid}&quot;)&#10;    @Operation(summary = &quot;Consultar si el usuario está bloqueado para viajar&quot;,&#10;            description = &quot;Devuelve true si el usuario NO puede viajar (saldo negativo/nulo o multas impagas), false si SÍ puede viajar&quot;)&#10;    public ResponseEntity&lt;?&gt; isBlockedForTravel(&#10;            @Parameter(description = &quot;UID del usuario&quot;, required = true)&#10;            @PathVariable(&quot;uid&quot;) String uidUser&#10;    ) {&#10;        boolean blocked = service.isUserBlockedForTravel(uidUser);&#10;        return ResponseEntity.ok(Map.of(&quot;uid&quot;, uidUser, &quot;blocked&quot;, blocked));&#10;    }&#10;&#10;    // --- Cobro de viaje ---&#10;    @PostMapping(&quot;/travel/charge/{uid}&quot;)&#10;    @Operation(summary = &quot;Cobrar viaje al usuario&quot;,&#10;            description = &quot;Cobra el viaje aplicando reglas de suscripción: si es MONTLY descuenta viajes, si es NONE descuenta balance y puede quedar negativo&quot;)&#10;    public ResponseEntity&lt;?&gt; chargeTravel(&#10;            @Parameter(description = &quot;UID del usuario&quot;, required = true)&#10;            @PathVariable(&quot;uid&quot;) String uidUser,&#10;            @Parameter(description = &quot;Valor total del viaje&quot;, required = true)&#10;            @RequestParam(&quot;total&quot;) Double totalTripValue,&#10;            @Parameter(description = &quot;Minutos excedentes&quot;, required = true)&#10;            @RequestParam(&quot;excessMinutes&quot;) Integer excessMinutes&#10;    ) {&#10;        try {&#10;            service.chargeTravel(totalTripValue, excessMinutes, uidUser);&#10;            return ResponseEntity.ok(Map.of(&#10;                    &quot;uid&quot;, uidUser,&#10;                    &quot;charged&quot;, true&#10;            ));&#10;        } catch (IllegalArgumentException e) {&#10;            return ResponseEntity.badRequest().body(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    @PostMapping(&quot;/subscription/purchase/{uid}&quot;)&#10;    @Operation(summary = &quot;Comprar suscripción mensual&quot;,&#10;            description = &quot;Compra la suscripción MONTHLY: establece subscriptionType='MONTHLY', suma 150 a subscriptionTravels y descuenta 39 del balance.&quot;)&#10;    public ResponseEntity&lt;?&gt; purchaseMonthlySubscription(&#10;            @Parameter(description = &quot;UID del usuario&quot;, required = true)&#10;            @PathVariable(&quot;uid&quot;) String uidUser&#10;    ) {&#10;        try {&#10;            User updated = service.purchaseMonthlySubscription(uidUser);&#10;            return ResponseEntity.ok(updated);&#10;        } catch (IllegalArgumentException e) {&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of(&quot;mensaje&quot;, e.getMessage()));&#10;        } catch (Exception ex) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of(&quot;mensaje&quot;, &quot;Error al procesar la compra: &quot; + ex.getMessage()));&#10;        }&#10;    }&#10;&#10;    private ResponseEntity&lt;Map&lt;String, String&gt;&gt; validate(BindingResult result) {&#10;        Map&lt;String,String&gt; errores = new HashMap&lt;&gt;();&#10;        result.getFieldErrors().forEach(err -&gt; errores.put(err.getField(), &quot;El campo &quot; + err.getField() + &quot; &quot; + err.getDefaultMessage()));&#10;        return ResponseEntity.badRequest().body(errores);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.movilidadsostenible.usuario.controllers;&#10;&#10;import com.movilidadsostenible.usuario.models.entity.User;&#10;import com.movilidadsostenible.usuario.services.UserService;&#10;import io.swagger.v3.oas.annotations.Operation;&#10;import io.swagger.v3.oas.annotations.Parameter;&#10;import io.swagger.v3.oas.annotations.media.Content;&#10;import io.swagger.v3.oas.annotations.media.Schema;&#10;import io.swagger.v3.oas.annotations.responses.ApiResponse;&#10;import io.swagger.v3.oas.annotations.tags.Tag;&#10;import jakarta.validation.Valid;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.validation.BindingResult;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.*;&#10;&#10;@RestController&#10;@Tag(name = &quot;Usuarios&quot;, description = &quot;Operaciones CRUD para usuarios&quot;)&#10;public class UserController {&#10;&#10;    @Autowired&#10;    private UserService service;&#10;&#10;    @GetMapping&#10;    @Operation(summary = &quot;Listar usuarios&quot;)&#10;    public List&lt;User&gt; listUsers() {&#10;        return service.listUsers();&#10;    }&#10;&#10;    @GetMapping(&quot;/login/{uid}&quot;)&#10;    @Operation(summary = &quot;Obtener usuario por UID&quot;,&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Encontrado&quot;,&#10;                            content = @Content(schema = @Schema(implementation = User.class))),&#10;                    @ApiResponse(responseCode = &quot;404&quot;, description = &quot;No encontrado&quot;)&#10;            })&#10;    public ResponseEntity&lt;?&gt; getUserById(&#10;            @Parameter(description = &quot;Identificador del usuario&quot;, required = true)&#10;            @PathVariable String uid) {&#10;        Optional&lt;User&gt; usuarioOptional = service.byId(uid);&#10;        return usuarioOptional.&lt;ResponseEntity&lt;?&gt;&gt;map(ResponseEntity::ok)&#10;                .orElseGet(() -&gt; ResponseEntity.notFound().build());&#10;    }&#10;&#10;    @PostMapping(&quot;/register&quot;)&#10;    @Operation(summary = &quot;Registrar usuario&quot;,&#10;            responses = {&#10;                    @ApiResponse(responseCode = &quot;201&quot;, description = &quot;Creado&quot;,&#10;                            content = @Content(schema = @Schema(implementation = User.class))),&#10;                    @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Validación fallida&quot;)&#10;            })&#10;    public ResponseEntity&lt;?&gt; createUser(@Valid @RequestBody User user,&#10;                                        BindingResult result) {&#10;        if (result.hasErrors()) {&#10;            return validate(result);&#10;        }&#10;        return ResponseEntity.status(HttpStatus.CREATED).body(service.save(user));&#10;    }&#10;&#10;    @PutMapping(&quot;/{uid}&quot;)&#10;    @Operation(summary = &quot;Actualizar usuario&quot;)&#10;    public ResponseEntity&lt;?&gt; updateUser(@Valid @RequestBody User user,&#10;                                        BindingResult result,&#10;                                        @PathVariable(&quot;uid&quot;) String uid) {&#10;        if (result.hasErrors()) {&#10;            return validate(result);&#10;        }&#10;        Optional&lt;User&gt; usuarioOptional = service.byId(uid);&#10;        if (usuarioOptional.isEmpty()) {&#10;            return ResponseEntity.notFound().build();&#10;        }&#10;        User usuarioDB = usuarioOptional.get();&#10;        // Actualización parcial segura&#10;        if (user.getUserName() != null) {&#10;            usuarioDB.setUserName(user.getUserName());&#10;        }&#10;        if (user.getSubscriptionType() != null) {&#10;            usuarioDB.setSubscriptionType(user.getSubscriptionType());&#10;        }&#10;        // Si el modelo incluye subcripcionTravels y viene presente, actualizarlo&#10;        try {&#10;            Integer travels = user.getSubscriptionTravels();&#10;            if (travels != null) {&#10;                usuarioDB.setSubscriptionTravels(travels);&#10;            }&#10;        } catch (Exception ignored) {&#10;            // Campo opcional, omitir si no existe&#10;        }&#10;        User saved = service.save(usuarioDB);&#10;        return ResponseEntity.ok(saved);&#10;    }&#10;&#10;    @DeleteMapping(&quot;/{id}&quot;)&#10;    @Operation(summary = &quot;Eliminar usuario&quot;)&#10;    public ResponseEntity&lt;?&gt; deleteUser(@PathVariable String uid) {&#10;        Optional&lt;User&gt; usuarioOptional = service.byId(uid);&#10;        if (usuarioOptional.isPresent()) {&#10;            service.delete(uid);&#10;            return ResponseEntity.ok().build();&#10;        }&#10;        return ResponseEntity.notFound().build();&#10;    }&#10;&#10;    // --- Endpoints de balance ---&#10;    @GetMapping(&quot;/balance/{uid}&quot;)&#10;    @Operation(summary = &quot;Obtener balance de usuario&quot;)&#10;    public ResponseEntity&lt;?&gt; getBalance(@PathVariable(&quot;uid&quot;) String uidUser) {&#10;        Double balance = service.getBalance(uidUser);&#10;        if (balance == null) {&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                    .body(Map.of(&quot;message&quot;, &quot;Usuario no encontrado&quot;));&#10;        }&#10;        return ResponseEntity.ok(Map.of(&quot;uid&quot;, uidUser, &quot;balance&quot;, balance));&#10;    }&#10;&#10;    @PostMapping(&quot;/balance/{uid}/add&quot;)&#10;    @Operation(summary = &quot;Agregar saldo al usuario&quot;)&#10;    public ResponseEntity&lt;?&gt; addBalance(@PathVariable(&quot;uid&quot;) String uidUser,&#10;                                        @RequestParam(&quot;amount&quot;) Double amount) {&#10;        try {&#10;            Double newBalance = service.addBalance(uidUser, amount);&#10;            return ResponseEntity.ok(Map.of(&quot;uid&quot;, uidUser, &quot;balance&quot;, newBalance));&#10;        } catch (IllegalArgumentException e) {&#10;            return ResponseEntity.badRequest().body(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    @PostMapping(&quot;/balance/{uid}/subtract&quot;)&#10;    @Operation(summary = &quot;Quitar saldo al usuario&quot;)&#10;    public ResponseEntity&lt;?&gt; subtractBalance(@PathVariable(&quot;uid&quot;) String uidUser,&#10;                                             @RequestParam(&quot;amount&quot;) Double amount) {&#10;        try {&#10;            Double newBalance = service.subtractBalance(uidUser, amount);&#10;            return ResponseEntity.ok(Map.of(&quot;uid&quot;, uidUser, &quot;balance&quot;, newBalance));&#10;        } catch (IllegalArgumentException e) {&#10;            return ResponseEntity.badRequest().body(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    @GetMapping(&quot;/travel/blocked/{uid}&quot;)&#10;    @Operation(summary = &quot;Consultar si el usuario está bloqueado para viajar&quot;,&#10;            description = &quot;Devuelve true si el usuario NO puede viajar (saldo negativo/nulo o multas impagas), false si SÍ puede viajar&quot;)&#10;    public ResponseEntity&lt;?&gt; isBlockedForTravel(&#10;            @Parameter(description = &quot;UID del usuario&quot;, required = true)&#10;            @PathVariable(&quot;uid&quot;) String uidUser&#10;    ) {&#10;        boolean blocked = service.isUserBlockedForTravel(uidUser);&#10;        return ResponseEntity.ok(Map.of(&quot;uid&quot;, uidUser, &quot;blocked&quot;, blocked));&#10;    }&#10;&#10;    // --- Cobro de viaje ---&#10;    @PostMapping(&quot;/travel/charge/{uid}&quot;)&#10;    @Operation(summary = &quot;Cobrar viaje al usuario&quot;,&#10;            description = &quot;Cobra el viaje aplicando reglas de suscripción: si es MONTLY descuenta viajes, si es NONE descuenta balance y puede quedar negativo&quot;)&#10;    public ResponseEntity&lt;?&gt; chargeTravel(&#10;            @Parameter(description = &quot;UID del usuario&quot;, required = true)&#10;            @PathVariable(&quot;uid&quot;) String uidUser,&#10;            @Parameter(description = &quot;Valor total del viaje&quot;, required = true)&#10;            @RequestParam(&quot;total&quot;) Double totalTripValue,&#10;            @Parameter(description = &quot;Minutos excedentes&quot;, required = true)&#10;            @RequestParam(&quot;excessMinutes&quot;) Integer excessMinutes&#10;    ) {&#10;        try {&#10;            service.chargeTravel(totalTripValue, excessMinutes, uidUser);&#10;            return ResponseEntity.ok(Map.of(&#10;                    &quot;uid&quot;, uidUser,&#10;                    &quot;charged&quot;, true&#10;            ));&#10;        } catch (IllegalArgumentException e) {&#10;            return ResponseEntity.badRequest().body(Map.of(&quot;error&quot;, e.getMessage()));&#10;        }&#10;    }&#10;&#10;    @PostMapping(&quot;/subscription/purchase/{uid}&quot;)&#10;    @Operation(summary = &quot;Comprar suscripción mensual&quot;,&#10;            description = &quot;Compra la suscripción MONTHLY: establece subscriptionType='MONTHLY', suma 150 a subscriptionTravels y descuenta 39 del balance.&quot;)&#10;    public ResponseEntity&lt;?&gt; purchaseMonthlySubscription(&#10;            @Parameter(description = &quot;UID del usuario&quot;, required = true)&#10;            @PathVariable(&quot;uid&quot;) String uidUser&#10;    ) {&#10;        try {&#10;            User updated = service.purchaseMonthlySubscription(uidUser);&#10;            return ResponseEntity.ok(updated);&#10;        } catch (IllegalArgumentException e) {&#10;            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of(&quot;mensaje&quot;, e.getMessage()));&#10;        } catch (Exception ex) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of(&quot;mensaje&quot;, &quot;Error al procesar la compra: &quot; + ex.getMessage()));&#10;        }&#10;    }&#10;&#10;    private ResponseEntity&lt;Map&lt;String, String&gt;&gt; validate(BindingResult result) {&#10;        Map&lt;String,String&gt; errores = new HashMap&lt;&gt;();&#10;        result.getFieldErrors().forEach(err -&gt; errores.put(err.getField(), &quot;El campo &quot; + err.getField() + &quot; &quot; + err.getDefaultMessage()));&#10;        return ResponseEntity.badRequest().body(errores);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/verify-system.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/verify-system.sh" />
              <option name="updatedContent" value="#!/bin/bash&#10;&#10;# Script de verificación final - Movilidad Sostenible OAuth2&#10;# Verifica que todos los componentes estén funcionando correctamente&#10;&#10;set -e&#10;&#10;echo &quot; Verificación Final - Movilidad Sostenible&quot;&#10;echo &quot;==============================================&quot;&#10;echo &quot;&quot;&#10;&#10;# Colores para output&#10;GREEN='\033[0;32m'&#10;RED='\033[0;31m'&#10;YELLOW='\033[1;33m'&#10;NC='\033[0m' # No Color&#10;&#10;# Función para verificar endpoint&#10;check_endpoint() {&#10;    local name=$1&#10;    local url=$2&#10;    local expected_code=${3:-200}&#10;    &#10;    echo -n &quot;Verificando $name... &quot;&#10;    &#10;    if response=$(curl -s -o /dev/null -w &quot;%{http_code}&quot; &quot;$url&quot; 2&gt;&amp;1); then&#10;        if [ &quot;$response&quot; = &quot;$expected_code&quot; ] || [ &quot;$response&quot; = &quot;200&quot; ] || [ &quot;$response&quot; = &quot;302&quot; ]; then&#10;            echo -e &quot;${GREEN}✓ OK${NC} (HTTP $response)&quot;&#10;            return 0&#10;        else&#10;            echo -e &quot;${YELLOW}⚠ Responde${NC} (HTTP $response)&quot;&#10;            return 0&#10;        fi&#10;    else&#10;        echo -e &quot;${RED}✗ No responde${NC}&quot;&#10;        return 1&#10;    fi&#10;}&#10;&#10;echo &quot; Verificando servicios base...&quot;&#10;echo &quot;&quot;&#10;&#10;check_endpoint &quot;Gateway&quot; &quot;http://localhost:8090/swagger-ui.html&quot;&#10;check_endpoint &quot;Auth Service&quot; &quot;http://localhost:9000/.well-known/openid-configuration&quot;&#10;check_endpoint &quot;Eureka Server&quot; &quot;http://localhost:8761&quot;&#10;check_endpoint &quot;Usuario Service&quot; &quot;http://localhost:8001/actuator/health&quot; || echo &quot;  (Normal si requiere autenticación)&quot;&#10;&#10;echo &quot;&quot;&#10;echo &quot; Verificando OAuth2...&quot;&#10;echo &quot;&quot;&#10;&#10;# Verificar OpenID Configuration a través del gateway&#10;check_endpoint &quot;OpenID Config (Gateway)&quot; &quot;http://localhost:8090/.well-known/openid-configuration&quot;&#10;&#10;# Verificar JWKS&#10;check_endpoint &quot;JWKS (Auth)&quot; &quot;http://localhost:9000/.well-known/jwks.json&quot;&#10;&#10;echo &quot;&quot;&#10;echo &quot; Probando obtención de token...&quot;&#10;echo &quot;&quot;&#10;&#10;TOKEN_RESPONSE=$(curl -s -X POST http://localhost:8090/oauth2/token \&#10;  -u user-client:12345 \&#10;  -H &quot;Content-Type: application/x-www-form-urlencoded&quot; \&#10;  -d &quot;grant_type=client_credentials&quot; \&#10;  -d &quot;scope=read write&quot; 2&gt;&amp;1)&#10;&#10;if echo &quot;$TOKEN_RESPONSE&quot; | grep -q &quot;access_token&quot;; then&#10;    echo -e &quot;${GREEN}✓ Token obtenido exitosamente${NC}&quot;&#10;    ACCESS_TOKEN=$(echo &quot;$TOKEN_RESPONSE&quot; | grep -o '&quot;access_token&quot;:&quot;[^&quot;]*&quot;' | cut -d'&quot;' -f4)&#10;    echo &quot;  Token (primeros 50 chars): ${ACCESS_TOKEN:0:50}...&quot;&#10;    echo &quot;&quot;&#10;    &#10;    # Guardar token&#10;    echo &quot;$ACCESS_TOKEN&quot; &gt; /tmp/gateway_token.txt&#10;    echo &quot;   Token guardado en: /tmp/gateway_token.txt&quot;&#10;    echo &quot;&quot;&#10;    &#10;    # Probar endpoint protegido con el token&#10;    echo &quot; Probando acceso a endpoint protegido con token...&quot;&#10;    HTTP_CODE=$(curl -s -o /dev/null -w &quot;%{http_code}&quot; http://localhost:8090/user/usuarios \&#10;      -H &quot;Authorization: Bearer $ACCESS_TOKEN&quot;)&#10;    &#10;    if [ &quot;$HTTP_CODE&quot; = &quot;200&quot; ]; then&#10;        echo -e &quot;${GREEN}✓ Endpoint protegido accesible con token${NC} (HTTP 200)&quot;&#10;    elif [ &quot;$HTTP_CODE&quot; = &quot;404&quot; ]; then&#10;        echo -e &quot;${YELLOW}⚠ Endpoint no encontrado${NC} (HTTP 404) - Puede ser normal si no existe el endpoint&quot;&#10;    elif [ &quot;$HTTP_CODE&quot; = &quot;401&quot; ]; then&#10;        echo -e &quot;${RED}✗ Token rechazado${NC} (HTTP 401)&quot;&#10;    else&#10;        echo -e &quot;${YELLOW}⚠ Respuesta inesperada${NC} (HTTP $HTTP_CODE)&quot;&#10;    fi&#10;else&#10;    echo -e &quot;${RED}✗ Error al obtener token${NC}&quot;&#10;    echo &quot;  Respuesta: $TOKEN_RESPONSE&quot;&#10;fi&#10;&#10;echo &quot;&quot;&#10;echo &quot; Estado de contenedores Docker...&quot;&#10;echo &quot;&quot;&#10;docker compose ps --format &quot;table {{.Service}}\t{{.Status}}\t{{.Ports}}&quot; 2&gt;/dev/null || docker-compose ps&#10;&#10;echo &quot;&quot;&#10;echo &quot;==============================================&quot;&#10;echo &quot; Resumen:&quot;&#10;echo &quot;&quot;&#10;echo &quot;✅ Si todos los checks anteriores están en verde/amarillo, tu sistema está funcionando.&quot;&#10;echo &quot;&quot;&#10;echo &quot; URLs importantes:&quot;&#10;echo &quot;   Gateway:           http://localhost:8090&quot;&#10;echo &quot;   Swagger UI:        http://localhost:8090/swagger-ui.html&quot;&#10;echo &quot;   Auth Service:      http://localhost:9000&quot;&#10;echo &quot;   Eureka:            http://localhost:8761&quot;&#10;echo &quot;&quot;&#10;echo &quot; Para usar el token guardado:&quot;&#10;echo &quot;   export TOKEN=\$(cat /tmp/gateway_token.txt)&quot;&#10;echo &quot;   curl -H \&quot;Authorization: Bearer \$TOKEN\&quot; http://localhost:8090/user/usuarios&quot;&#10;echo &quot;&quot;&#10;echo &quot; Ver logs:&quot;&#10;echo &quot;   docker compose logs -f gateway-server&quot;&#10;echo &quot;   docker compose logs -f auth-service&quot;&#10;echo &quot;&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/viaje-service/src/main/java/com/movilidadsostenible/viaje_service/clients/dto/SlotRequestDTO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/viaje-service/src/main/java/com/movilidadsostenible/viaje_service/clients/dto/SlotRequestDTO.java" />
              <option name="updatedContent" value="package com.movilidadsostenible.viaje_service.clients.dto;&#10;&#10;public class SlotRequestDTO {&#10;    private String idSlot;&#10;    private String padlockStatus;&#10;    private Integer stationId;&#10;    private String bicycleId;&#10;&#10;    public SlotRequestDTO() {}&#10;&#10;    public SlotRequestDTO(String idSlot, String padlockStatus, Integer stationId, String bicycleId) {&#10;        this.idSlot = idSlot;&#10;        this.padlockStatus = padlockStatus;&#10;        this.stationId = stationId;&#10;        this.bicycleId = bicycleId;&#10;    }&#10;&#10;    public String getIdSlot() { return idSlot; }&#10;    public void setIdSlot(String idSlot) { this.idSlot = idSlot; }&#10;&#10;    public String getPadlockStatus() { return padlockStatus; }&#10;    public void setPadlockStatus(String padlockStatus) { this.padlockStatus = padlockStatus; }&#10;&#10;    public Integer getStationId() { return stationId; }&#10;    public void setStationId(Integer stationId) { this.stationId = stationId; }&#10;&#10;    public String getBicycleId() { return bicycleId; }&#10;    public void setBicycleId(String bicycleId) { this.bicycleId = bicycleId; }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>